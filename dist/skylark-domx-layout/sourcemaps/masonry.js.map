{"version":3,"sources":["masonry.js"],"names":["define","langx","finder","geom","styler","layouts","MasonryLayouter","klass","_measureColumns","children","bounds","container","_","this","calculated","columnWidth","firstItem","extraWidth","width","gutter","containerWidth","cols","excess","Math","max","_positionItem","item","x","y","isInstant","css","position","relativePositionitem","left","top","animation","moveto","_getColGroup","colSpan","colYs","colGroup","groupCount","i","groupColYs","slice","apply","_getItemLayoutPosition","itemSize","marginSize","remainder","min","minimumY","shortColIndex","indexOf","setHeight","height","setSpan","length","_filterItems","items","_resetLayout","push","maxY","_calcLayout","calcInfos","forEach","_postLayout","autoFit","domNode","style","calcInfo","layout","clientSize","init","options","mixin","masonry"],"mappings":"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","file":"../masonry.js","sourcesContent":["define([\r\n    \"skylark-langx/langx\",\r\n    \"skylark-utils-dom/finder\",\r\n    \"skylark-utils-dom/geom\",\r\n    \"skylark-utils-dom/styler\",\r\n    \"./layouts\"\r\n],function(langx,finder,geom,styler,layouts) {\r\n    // summary:\r\n    //  The masnory layouter is a masonry grid layout manager. \r\n   \r\n    var MasonryLayouter = langx.klass({\r\n        _measureColumns: function(children, bounds, container) {\r\n\r\n            var _ = this._,\r\n                calculated = _.calculated;\r\n            // if columnWidth is 0, default to outerWidth of first item\r\n            if (!_.columnWidth) {\r\n                var firstItem = children[0];\r\n                // columnWidth fall back to item of first element\r\n                calculated.columnWidth = firstItem && firstItem.bounds().extraWidth() || bounds.width;\r\n            } else {\r\n                calculated.columnWidth = _.columnWidth;\r\n            }\r\n\r\n            var columnWidth = calculated.columnWidth += _.gutter;\r\n\r\n            // calculate columns\r\n            var containerWidth = bounds.width + _.gutter;\r\n            var cols;\r\n            if (_.cols) {\r\n                cols = _.cols;\r\n            } else {\r\n                var cols = containerWidth / columnWidth;\r\n                // fix rounding errors, typically with gutters\r\n                var excess = columnWidth - containerWidth % columnWidth;\r\n                // if overshoot is less than a pixel, round up, otherwise floor it\r\n                var mathMethod = excess && excess < 1 ? 'round' : 'floor';\r\n                cols = Math[mathMethod](cols);\r\n            }\r\n            calculated.cols = Math.max(cols, 1);\r\n        },\r\n\r\n        _positionItem: function(item, x, y, isInstant) {\r\n            styler.css(item, {\r\n                position: \"absolute\" \r\n            });\r\n            if (isInstant) {\r\n                // if not transition, just set CSS\r\n                geom.relativePositionitem(item,{\r\n                    left : x,\r\n                    top : y\r\n                });\r\n            } else {\r\n                item[this._.animation] ? item[this._.animation](x, y) : item.moveto(x, y);\r\n            }\r\n        },\r\n        _getColGroup: function(colSpan) {\r\n            var _ = this._,\r\n                calculated = _.calculated;\r\n\r\n            if (colSpan < 2) {\r\n                // if brick spans only one column, use all the column Ys\r\n                return calculated.colYs;\r\n            }\r\n\r\n            var colGroup = [];\r\n            // how many different places could this brick fit horizontally\r\n            var groupCount = calculated.cols + 1 - colSpan;\r\n            // for each group potential horizontal position\r\n            for (var i = 0; i < groupCount; i++) {\r\n                // make an array of colY values for that one group\r\n                var groupColYs = calculated.colYs.slice(i, i + colSpan);\r\n                // and get the max value of the array\r\n                colGroup[i] = Math.max.apply(Math, groupColYs);\r\n            }\r\n            return colGroup;\r\n        },\r\n\r\n        _getItemLayoutPosition: function(item) {\r\n            var _ = this._,\r\n                calculated = _.calculated;\r\n\r\n            var itemSize = geom.marginSize(item);\r\n            // how many columns does this brick span\r\n            var remainder = itemSize.width % calculated.columnWidth;\r\n            var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\r\n            // round if off by 1 pixel, otherwise use ceil\r\n            var colSpan = Math[mathMethod](itemSize.width / calculated.columnWidth);\r\n            colSpan = Math.min(colSpan, calculated.cols);\r\n\r\n            var colGroup = this._getColGroup(colSpan);\r\n            // get the minimum Y value from the columns\r\n            var minimumY = Math.min.apply(Math, colGroup);\r\n            var shortColIndex = colGroup.indexOf(minimumY);\r\n\r\n            // position the brick\r\n            var position = {\r\n                x: calculated.columnWidth * shortColIndex,\r\n                y: minimumY\r\n            };\r\n\r\n            // apply setHeight to necessary columns\r\n            var setHeight = minimumY + itemSize.height;\r\n            var setSpan = calculated.cols + 1 - colGroup.length;\r\n            for (var i = 0; i < setSpan; i++) {\r\n                calculated.colYs[shortColIndex + i] = setHeight;\r\n            }\r\n            return position;\r\n        },\r\n\r\n        \"_filterItems\": function(items) {\r\n            return items;\r\n        },\r\n\r\n        \"_resetLayout\": function(children, bounds, container) {\r\n            var _ = this._,\r\n                calculated = _.calculated;\r\n            this._measureColumns(children, bounds, container);\r\n\r\n            // reset column Y\r\n            calculated.colYs = [];\r\n            for (var i = 0; i < calculated.cols; i++) {\r\n                calculated.colYs.push(0);\r\n            }\r\n            calculated.maxY = 0;\r\n        },\r\n\r\n        \"_calcLayout\": function(children, bounds, container) {\r\n            this._resetLayout(children, bounds, container);\r\n            var calcInfos = [];\r\n\r\n            children.forEach(function(item) {\r\n                // get x/y object from method\r\n                var position = this._getItemLayoutPosition(item);\r\n                // enqueue\r\n                position.item = item;\r\n                //position.isInstant = isInstant || item.isLayoutInstant;\r\n                calcInfos.push(position);\r\n            }, this);\r\n            return calcInfos;\r\n        },\r\n\r\n        \"_postLayout\": function(calcInfos, container) {\r\n            var _ = this._;\r\n            if (_.autoFit) {\r\n                //var size = container.size;\r\n                //size.height = _.calculated.maxY;\r\n                //container.size = size;\r\n                //TODO: needs a better implementation\r\n                var calculated = _.calculated,\r\n                    maxY = Math.max.apply(Math, calculated.colYs);\r\n\r\n                container.domNode.style.height = maxY + \"px\";\r\n            }\r\n            calcInfos.forEach(function(calcInfo) {\r\n                this._positionItem(calcInfo.item, calcInfo.x, calcInfo.y, calcInfo.isInstant);\r\n            }, this);\r\n            //return children;\r\n        },\r\n\r\n        \"layout\": function() {\r\n            var _ = this._,\r\n                container = _.container,\r\n                children = finder.children(container,_.items),\r\n                bounds = geom.clientSize(container);\r\n                \r\n            var calcInfos = this._calcLayout(children,bounds,container);\r\n            this._postLayout(calcInfos,container);\r\n        },\r\n\r\n        \"init\": function(container,options) {\r\n            var _ = this._ =  langx.mixin ({\r\n                autoFit: true, //dd\r\n                columnWidth: 0, //dd\r\n                cols: 0, //d\r\n                gutter: 0, //\r\n                animation: \"moveto\", //dd\r\n                calculated: {\r\n                    colYs: null,\r\n                    columnWidth: 0,\r\n                    cols: 0\r\n                }\r\n            },options);\r\n            _.container = container;\r\n        }\r\n    });\r\n\r\n    \r\n    var masonry  = layouts.masonry = function(container,options) {\r\n        var layouter = new MasonryLayouter(container,options);\r\n        layouter.layout();\r\n    };\r\n\r\n    return masonry;\r\n});\r\n"]}